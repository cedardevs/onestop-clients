import json

from datetime import datetime, timezone
from onestop.util.ClientLogger import ClientLogger

class SqsConsumer:
    """
    A class used to consume messages from sqs queue

    Attributes
    ----------
        logger: ClientLogger object
                utilizes python logger library and creates logging for our specific needs

    Methods
    -------
        receive_messages(sqs_client, sqs_queue_name, sqs_max_polls, cb)
            polls for messages in the queue
    """

    def __init__(self, log_level = 'INFO', **wildargs):
        """
        Attributes
        ----------
            log_level: str
                The log level to use for this class (Defaults to 'INFO')
        """
        self.log_level = log_level
        self.logger = ClientLogger.get_logger(self.__class__.__name__, log_level, False)
        self.logger.info("Initializing " + self.__class__.__name__)

        if wildargs:
            self.logger.warning("There were extra constructor arguments: " + str(wildargs))

    def connect(self, sqs_resource, sqs_queue_name):
        """
        Gets a boto SQS.Queue resource.
        :param sqs_resource: boto SQS.Resource
            SQS resource to create the queue from.
        :param sqs_queue_name: str
            SQS queue name to create and return a boto SQS.Queue object to.
        :return: SQS.Queue
            An SQS.Queue resource to use for Queue operations.
        """
        return sqs_resource.create_queue(QueueName=sqs_queue_name)

    def receive_messages(self, sqs_queue, sqs_max_polls, cb):
        """
        Polls for messages from an sqs queue

        :param sqs_queue: boto SQS.Queue object
            boto SQS Queue object. Can be generated by the method in this class.
        :param sqs_max_polls: int
            number of polls
        :param cb: function
            call back function

        :return: If the Message has a Records key then the call back function gets called on the Message.

        """
        self.logger.info("Receive messages")
        self.logger.info("Polling %d time(s) for SQS messages" % sqs_max_polls)

        if sqs_max_polls < 1:
            raise ValueError('Max polling value should be greater than 0.')

        for i in range(1, sqs_max_polls+1):
            self.logger.info("Polling attempt: " + str(i))

            # boto3 SQS.Queue appears to have a subset of SQS.Client methods plus a few management queue ones.
            # The ones they do share seem to have different return types.
            # The message method names are different and return types different:
            #  Client.send_message and Queue.send_message and Queue.send_messages
            #  Client.receive_message and Queue.receive_messages
            sqs_messages = sqs_queue.receive_messages(
                MaxNumberOfMessages=10,
                WaitTimeSeconds=10
            )
            self.logger.info("Received %d messages." % len(sqs_messages))
            self.logger.debug("Messages: %s" % sqs_messages)

            for sqs_message in sqs_messages:
                try:
                    # Log start time
                    dt_start = datetime.now(tz=timezone.utc)
                    self.logger.info("Starting processing message")
                    self.logger.debug("Message: %s" % sqs_message)
                    self.logger.debug("Message body: %s" % sqs_message.body)

                    message_body = json.loads(sqs_message.body)
                    self.logger.debug("Message body message: %s" % message_body['Message'])
                    message_content = json.loads(message_body['Message'])

                    if 'Records' in message_content:
                        recs = message_content['Records']
                        self.logger.debug('Message "Records": %s' % recs)
                        cb(recs, self.log_level)
                    else:
                        self.logger.info("s3 event message without 'Records' content received.")

                    sqs_message.delete()

                    self.logger.info("The SQS message has been deleted.")

                    dt_end = datetime.now(tz=timezone.utc)
                    processing_time = dt_end - dt_start

                    self.logger.info("Completed processing message (s):" + str(processing_time.microseconds * 1000))

                except:
                    self.logger.exception(
                        "An exception was thrown while processing a message, but this program will continue. The "
                        "message will not be deleted from the SQS queue. The message was: %s" % sqs_message)
